# 假期配置文件迁移方案

## 当前状态分析

### 1. 现有架构
- **核心模块**: `modules/isFreeDay.ts`
- **配置文件**: `static/holiday/2025.json`
- **使用页面**:
  - `pages/using/using.vue`
  - `pages/order/order.vue`
  - `pages/index/index.vue`
  - `pages/index/usage.vue`
  - `pages/start/start.vue`

### 2. 当前问题
- 假期配置文件硬编码在静态资源中
- 每年需要手动更新文件
- 无法动态更新假期配置
- 配置分散在前端多个文件中

## 迁移方案

### 方案一：迁移到uniCloud网页托管（推荐）

#### 1.1 文件结构设计
```
uniCloud/hosting/
├── holiday/
│   ├── 2025.json          # 2025年假期配置
│   ├── 2026.json          # 2026年假期配置
│   └── latest.json         # 最新年份的软链接
└── meta/
    └── holiday-info.json   # 假期配置元信息
```

#### 1.2 假期配置文件格式
```json
// uniCloud/hosting/holiday/2025.json
{
  "$schema": "https://raw.githubusercontent.com/NateScarlet/holiday-cn/master/schema.json",
  "$id": "https://your-domain.cn/holiday/2025.json",
  "year": 2025,
  "papers": [
    "https://www.gov.cn/zhengce/zhengceku/202411/content_6986383.htm"
  ],
  "days": [
    {
      "name": "元旦",
      "date": "2025-01-01",
      "isOffDay": true
    },
    {
      "name": "春节",
      "date": "2025-01-28",
      "isOffDay": true
    },
    {
      "name": "春节调休",
      "date": "2025-01-26",
      "isOffDay": false
    }
  ]
}
```

#### 1.3 元信息文件
```json
// uniCloud/hosting/meta/holiday-info.json
{
  "currentYear": 2025,
  "availableYears": [2025, 2026],
  "lastUpdate": "2024-12-01T00:00:00.000Z",
  "checksum": {
    "2025": "abc123def456...",
    "2026": "xyz789abc123..."
  }
}
```

#### 1.4 修改isFreeDay.ts模块（支持年份自动判断）
```typescript
// modules/isFreeDay.ts
import dayjs from 'dayjs';

interface HolidayConfig {
  year: number;
  days: Array<{
    name: string;
    date: string;
    isOffDay: boolean;
  }>;
}

// 本地缓存
let holidayCache: Map<number, HolidayConfig> = new Map();
let cacheTimestamp: Map<number, number> = new Map();
const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24小时缓存

// 网页托管域名配置
const HOSTING_DOMAIN = 'https://your-unicloud-domain.cn';

/**
 * 从网页托管获取假期配置
 */
async function fetchHolidayConfig(year: number): Promise<HolidayConfig | null> {
  try {
    const response = await uni.request({
      url: `${HOSTING_DOMAIN}/holiday/${year}.json`,
      method: 'GET',
      timeout: 5000 // 5秒超时
    });

    if (response.statusCode === 200 && response.data) {
      return response.data;
    }
    return null;
  } catch (error) {
    console.error(`获取${year}年假期配置失败:`, error);
    return null;
  }
}

/**
 * 检查本地缓存是否有效
 */
function isCacheValid(year: number): boolean {
  const timestamp = cacheTimestamp.get(year) || 0;
  return Date.now() - timestamp < CACHE_DURATION;
}

/**
 * 从本地缓存获取配置
 */
function getLocalCache(year: number): HolidayConfig | null {
  if (!isCacheValid(year)) {
    return null;
  }
  return holidayCache.get(year) || null;
}

/**
 * 保存到本地缓存
 */
function setLocalCache(year: number, config: HolidayConfig): void {
  holidayCache.set(year, config);
  cacheTimestamp.set(year, Date.now());
}

/**
 * 获取内置默认配置（降级用）
 */
function getDefaultHolidayConfig(year: number): HolidayConfig {
  // 提供基本的周末判断
  return {
    year,
    days: []
  };
}

export default async function isFreeDay(timestamp?: number): Promise<boolean> {
  const now = dayjs(timestamp).format('YYYY-MM-DD');
  const next = dayjs(timestamp).add(1, 'day').format('YYYY-MM-DD');
  const year = dayjs(timestamp).year();

  try {
    // 尝试从缓存获取
    let config = getLocalCache(year);

    if (!config) {
      // 从网页托管获取配置 - 根据年份动态获取
      config = await fetchHolidayConfig(year);

      if (config) {
        // 缓存到本地
        setLocalCache(year, config);
      } else {
        // 使用默认配置
        config = getDefaultHolidayConfig(year);
      }
    }

    // 查找下一天的配置
    const nextDayConfig = config.days.find(data => data.date === next);
    if (nextDayConfig) {
      return !nextDayConfig.isOffDay;
    }

    // 查找当天的配置
    const todayConfig = config.days.find(data => data.date === now);
    if (todayConfig?.isOffDay) {
      return false;
    }

    // 默认工作日判断
    const today = dayjs(timestamp).day();
    return (0 < today && today < 5);
  } catch (error) {
    console.error('假期判断失败:', error);
    // 降级处理：只根据星期几判断
    const today = dayjs(timestamp).day();
    return (0 < today && today < 5);
  }
}

/**
 * 清除假期配置缓存
 */
export function clearHolidayCache(year?: number): void {
  if (year) {
    holidayCache.delete(year);
    cacheTimestamp.delete(year);
  } else {
    holidayCache.clear();
    cacheTimestamp.clear();
  }
}

/**
 * 预加载假期配置
 */
export async function preloadHolidayConfig(year: number): Promise<void> {
  if (!isCacheValid(year)) {
    const config = await fetchHolidayConfig(year);
    if (config) {
      setLocalCache(year, config);
    }
  }
}
```

#### 1.5 创建假期配置管理工具
```typescript
// utils/holidayManager.ts
import dayjs from 'dayjs';

const HOSTING_DOMAIN = 'https://your-unicloud-domain.cn';

export interface HolidayUploadConfig {
  year: number;
  days: Array<{
    name: string;
    date: string;
    isOffDay: boolean;
  }>;
}

/**
 * 上传假期配置到网页托管
 */
export async function uploadHolidayConfig(config: HolidayUploadConfig): Promise<boolean> {
  try {
    // 这里需要调用uniCloud的上传文件API
    // 实际实现取决于您如何管理文件上传
    console.log('上传假期配置:', config);
    return true;
  } catch (error) {
    console.error('上传假期配置失败:', error);
    return false;
  }
}

/**
 * 验证假期配置格式
 */
export function validateHolidayConfig(config: any): config is HolidayUploadConfig {
  if (!config || typeof config !== 'object') return false;
  if (!config.year || !Array.isArray(config.days)) return false;

  return config.days.every(day =>
    day.name &&
    day.date &&
    typeof day.isOffDay === 'boolean' &&
    /^\d{4}-\d{2}-\d{2}$/.test(day.date)
  );
}

/**
 * 生成假期配置文件内容
 */
export function generateHolidayConfig(config: HolidayUploadConfig): string {
  return JSON.stringify({
    $schema: "https://raw.githubusercontent.com/NateScarlet/holiday-cn/master/schema.json",
    $id: `${HOSTING_DOMAIN}/holiday/${config.year}.json`,
    year: config.year,
    papers: [],
    days: config.days
  }, null, 2);
}
```

### 方案二：网页托管 + 云函数备份

#### 2.1 实现逻辑
```typescript
// modules/isFreeDay.ts (方案二)
import dayjs from 'dayjs';

const HOSTING_DOMAIN = 'https://your-unicloud-domain.cn';

export default async function isFreeDay(timestamp?: number): Promise<boolean> {
  const now = dayjs(timestamp).format('YYYY-MM-DD');
  const next = dayjs(timestamp).add(1, 'day').format('YYYY-MM-DD');
  const year = dayjs(timestamp).year();

  try {
    // 优先从网页托管获取
    const config = await fetchHolidayConfigFromHosting(year);

    if (!config) {
      // 降级到云函数
      const fallbackConfig = await fetchHolidayConfigFromCloudFunction(year);
      if (fallbackConfig) {
        return processHolidayJudgment(fallbackConfig, now, next);
      }
    } else {
      return processHolidayJudgment(config, now, next);
    }

    // 默认工作日判断
    const today = dayjs(timestamp).day();
    return (0 < today && today < 5);
  } catch (error) {
    console.error('假期判断失败:', error);
    const today = dayjs(timestamp).day();
    return (0 < today && today < 5);
  }
}

async function fetchHolidayConfigFromHosting(year: number): Promise<any> {
  try {
    const response = await uni.request({
      url: `${HOSTING_DOMAIN}/holiday/${year}.json`,
      method: 'GET',
      timeout: 3000
    });
    return response.statusCode === 200 ? response.data : null;
  } catch {
    return null;
  }
}

async function fetchHolidayConfigFromCloudFunction(year: number): Promise<any> {
  try {
    // 降级到云函数获取配置
    const result = await uniCloud.importObject('todo').getHolidayConfig({ year });
    return result.errCode === 0 ? result.data : null;
  } catch {
    return null;
  }
}

function processHolidayJudgment(config: any, now: string, next: string): boolean {
  const nextDayConfig = config.days?.find((data: any) => data.date === next);
  if (nextDayConfig) {
    return !nextDayConfig.isOffDay;
  }

  const todayConfig = config.days?.find((data: any) => data.date === now);
  if (todayConfig?.isOffDay) {
    return false;
  }

  return true; // 如果没有特殊配置，假设为工作日
}
```

## 实施步骤

### 第一步：配置uniCloud网页托管
1. 开通uniCloud网页托管服务
2. 配置自定义域名（可选）
3. 创建文件夹结构：
   ```
   uniCloud/hosting/
   ├── holiday/
   │   ├── 2025.json
   │   ├── 2026.json
   │   └── latest.json
   └── meta/
       └── holiday-info.json
   ```

### 第二步：上传假期配置文件
1. 使用uniCloud后台的文件管理功能上传现有 `static/holiday/2025.json`
2. 创建元信息文件 `holiday-info.json` 并上传
3. 测试文件可访问性

### 第三步：修改核心模块
1. 修改 `modules/isFreeDay.ts` 为异步函数
2. 实现网页托管的配置获取逻辑
3. 添加本地缓存机制
4. 实现降级处理方案

### 第四步：更新使用页面
1. 修改以下页面的假期判断调用：
   - `pages/using/using.vue`
   - `pages/order/order.vue`
   - `pages/index/index.vue`
   - `pages/index/usage.vue`
   - `pages/start/start.vue`
2. 将同步调用改为异步调用
3. 添加加载状态和错误处理

### 第五步：测试和优化
1. 测试各种网络条件下的功能
2. 验证缓存机制的有效性
3. 优化性能和用户体验

## 优缺点对比

### 方案一：uniCloud网页托管（推荐）
**优点**：
- 静态文件访问速度快
- 支持CDN加速
- 更新简单，无需重新部署
- 成本低廉，网页托管免费额度高
- 便于版本控制和备份
- 支持自定义域名和HTTPS

**缺点**：
- 需要额外的缓存机制
- 网络依赖性较强
- 需要手动管理文件上传

### 方案二：网页托管 + 云函数备份
**优点**：
- 高可用性，双重保障
- 网页托管故障时可降级到云函数
- 数据安全性更高

**缺点**：
- 实现复杂度较高
- 需要维护两份数据
- 成本略高

### 方案三：纯数据库方案
**优点**：
- 动态配置，实时生效
- 支持复杂的数据管理
- 便于实现管理后台

**缺点**：
- 数据库负载增加
- 响应速度相对较慢
- 实现复杂度高

## 建议实施方案

推荐采用**方案一：uniCloud网页托管**，具体原因：

1. **性能优越**：静态文件访问速度快，支持CDN加速
2. **成本低廉**：uniCloud网页托管有免费额度，成本几乎为零
3. **维护简单**：只需上传JSON文件，无需复杂的数据库操作
4. **可靠性高**：阿里云CDN保障，多节点备份
5. **扩展性好**：便于后续添加更多年份和配置
6. **用户体验**：配合本地缓存机制，首次加载后响应迅速

### 技术实现要点

1. **缓存策略**：24小时本地缓存，减少重复请求
2. **降级处理**：网络异常时自动降级到基础工作日判断
3. **预加载机制**：应用启动时可预加载当前年份配置
4. **版本管理**：支持多年份并存，便于历史查询

## 年份自动判断逻辑

### 当前问题
现有代码只读取2025年的假期配置，无法根据传入的时间戳自动判断应该使用哪一年的假期数据。

### 解决方案
在修改后的`isFreeDay.ts`中，通过以下逻辑实现年份自动判断：

```typescript
// 1. 从传入的时间戳提取年份
const year = dayjs(timestamp).year();

// 2. 动态构建对应年份的URL
const url = `${HOSTING_DOMAIN}/holiday/${year}.json`;

// 3. 按年份缓存数据
let config = getLocalCache(year);
```

### 支持多年份并存
- 网页托管目录结构支持多年份配置并存
- 每个年份的缓存独立管理
- 跨年查询时自动获取对应年份的数据

### 文件命名规范
```
uniCloud/hosting/holiday/
├── 2025.json    # 2025年假期配置
├── 2026.json    # 2026年假期配置
├── 2027.json    # 2027年假期配置
└── latest.json   # 最新年份的软链接（可选）
```

### 实施优先级

1. **高优先级**：基础功能实现和缓存机制
2. **中优先级**：管理后台文件上传功能
3. **低优先级**：备份机制和高级特性

## 注意事项

### 网页托管相关
1. **域名配置**：建议配置自定义域名，便于后续迁移
2. **HTTPS支持**：uniCloud网页托管自动支持HTTPS，无需额外配置
3. **跨域设置**：确保网页托管支持跨域访问
4. **文件命名**：按年份命名，便于管理和版本控制

### 缓存策略
1. **缓存时间**：建议设置为24小时，避免频繁请求
2. **缓存清理**：提供手动清理缓存的方法
3. **离线支持**：网络异常时使用基础工作日判断

### 文件管理
1. **版本控制**：假期配置文件应该纳入Git版本管理
2. **备份策略**：保留多版本备份，便于回滚
3. **更新流程**：使用uniCloud后台文件管理功能上传和更新配置文件

### 测试验证
1. **网络条件**：测试各种网络环境下的功能
2. **边界情况**：测试跨年、闰年等特殊情况
3. **性能测试**：验证缓存机制的有效性

### 安全考虑
1. **访问控制**：虽然配置文件公开，但应避免敏感信息
2. **数据验证**：对下载的配置文件进行格式验证
3. **防刷机制**：避免恶意频繁请求

---

*此迁移方案可根据实际需求和技术架构进行调整。*